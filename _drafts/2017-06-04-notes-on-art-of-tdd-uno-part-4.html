---
layout: post
title: Notes on the Art of TDD - Uno (Part 4)
date: '2017-06-04T10:46:00.003+02:00'
author: John
tags:
- ood series
- tdd
modified_time: '2017-06-19T18:05:33.404+02:00'
blogger_id: tag:blogger.com,1999:blog-525051364647796957.post-8476599929090284071
blogger_orig_url: http://john-hearn.blogspot.com/2017/06/notes-on-art-of-tdd-uno-part-4.html
---

<div>[Continued from <a href="http://john-hearn.blogspot.com/2017/06/notes-on-art-of-tdd-uno-part-3.html" target="_blank">Part 3</a>]</div><div><br /></div><div>Let's get on to the final important part of the game - scoring.</div><blockquote class="tr_bq"><span style="color: blue;">At the end of the game all opponents’ cards are given to the winner and points are counted. All number cards are the same value as the number on the card (e.g. a 9 is 9 points). “Draw Two" – 20 Points, “Reverse" – 20 Points, “Skip" – 20 Points, “Wild" – 50 Points, and “Wild Draw Four" – 50 Points. The first player to attain 500 points wins the game.</span></blockquote><div>This should be straightforward to test, hopefully. As always, we test bit by bit. First card scores. The best place for this is in the cards themselves. Here's a test for the Draw Two card.</div><blockquote class="tr_bq"><span style="color: blue;">All number cards are the same value as the number on the card</span></blockquote><pre class="brush:java">@Test        <br />public void testCardPoints() {        <br />  Card card = new Card(5, Colour.BLUE);        <br />  assertThat(card.points()).isEqualTo(5);        <br />}        <br /></pre><br />Likewise the action cards:<br /><blockquote class="tr_bq"><span style="color: blue;">“Draw Two" – 20 Points</span></blockquote><div><pre class="brush:java">@Test<br />public void testDrawTwoCardPoints() {        <br />  DrawTwoCard drawTwoCard = new DrawTwoCard(Colour.BLUE);        <br />  assertThat(drawTwoCard.points()).isEqualTo(20);        <br />}        <br /></pre></div><div><br /></div><div>That's trivial to implement. The others are similar. One interesting point though is how to ensure we've covered all the cards? We have used a hierarchy to model the different card types (I'm happy with that because WildFourCard&nbsp;<b><i>is a</i></b>&nbsp;WildCard, etc.) so the superclass may have a default implementation which may not necessarily be tested. The only way to ensure we cover all cases is to add tests systematically for each card type which is error prone.&nbsp;</div><blockquote class="tr_bq"><span style="color: blue;">All opponents’ cards are given to the winner and points are counted</span></blockquote><div><pre class="brush:java">@Test<br />public void testAddUpScores() {        <br />  Player winner = game.play();        <br />  for (Player player : players) {        <br />    if (player == winner) {        <br />      assertThat(player.score()).isGreaterThan(0);        <br />    } else {        <br />      assertThat(player.score()).isEqualTo(0);        <br />    }        <br />  }        <br />}        <br /></pre></div><div><br /></div><div>Now the last point.</div><blockquote class="tr_bq"><span style="color: blue;">The first player to attain 500 points wins the game.</span></blockquote><div>Notice that the word "game" is being used in a different way - now to represent the entire game and earlier to represent a single round. We're going to use the word "round" to represent a single hand and the word "game" for all the rounds until we get a final winner. Rename with the IDE and the tests still work.&nbsp;<span style="color: #38761d; font-size: large;">TDD gives you some confidence after a big refactor like this which is nice.</span>&nbsp; I also notice an unused method (originally created for testing, it seems). Delete that too. And the tests still green.&nbsp;</div><div><br /></div><div>Now a test for the whole game.<br /><br /></div><div><pre class="brush:java">@Test<br />public void testGame() {        <br />  Game game = new Game(players);        <br />  Player winner = game.play();        <br />        <br />  for (Player player : players) {        <br />    if (player == winner) {        <br />      assertThat(player.score()).isGreaterThanOrEqualTo(500);<br />    } else {        <br />      assertThat(player.score()).isLessThan(500);        <br />    }        <br />  }        <br />}        <br /></pre></div><div><br /></div><div>The IDE generates the skeleton Game class. The play method is simple.</div><div><br /></div><div><pre class="brush:java">public Player play() {        <br />  while (true) {        <br />    Round game = new Round(players);        <br />    Player winner = game.play();        <br />    if (winner.score() &gt; 500) {        <br />      return winner;        <br />    }        <br />  }        <br />}        <br /></pre></div><div><br /></div><div>That's elegant and works great however a similar situation as before has occurred. I have found a bug not covered by the tests. This time, because we're reusing the player objects, their hands are not being reset after each round. How can we ensure these oversights don't happen? Once again the test is harder than the fix. One idea is to avoid creating a pack instance every time and reuse the same one. In that case the number of cards in the pack must always be the same at the start of a game. It also means the pack can be reused. At the end of a round, cards are replaced in the pack from the pile and each player's hand, just as in a real game. We extract another protected method, playRound() which just plays the round. The outer play() method will put all cards back into the pack at the end of the round. The test is essentially the same as the existing play() test case.</div><div><br /></div><div><pre class="brush:java">@Test<br />public void testPlayRound() {        <br />  Player winner = round.playRound();        <br />  for (Player player : players) {        <br />    if (player == winner) {        <br />      assertThat(player.numCards()).isEqualTo(0);        <br />    } else {        <br />      assertThat(player.numCards()).isNotEqualTo(0);        <br />    }        <br />  }        <br />}        <br /></pre></div><div><br /></div><div>After refactoring, the play() method becomes.</div><div><div><br /></div><pre class="brush:java">public Player play() {        <br />  Player winner = playRound();        <br />  return winner;        <br />}        <br /></pre></div><div><br /></div><div>Then we add a new test to make sure all the cards are put back in the pack</div><div><br /></div><div><pre class="brush:java">public void testPlay() {        <br />  int numCards = pack.numCards();        <br />  round.play();        <br />  for (Player player : players) {        <br />    assertThat(player.numCards()).isEqualTo(0);        <br />  }        <br />  assertThat(pile.numCards()).isEqualTo(0);        <br />  assertThat(pack.numCards()).isEqualTo(numCards);        <br />}        <br /></pre><div><br /></div></div><div>Luckily we already have a method in pack that does nearly exactly what we want: resetPack(pile). We rename it to putCards() and, by letting it take a CardHolder instead of a Pile, we can use it to make this latest test pass.&nbsp;</div><div><br /></div><div><pre class="brush:java">public Player play() {        <br />  Player winner = playRound();        <br />  for(Player player : players) {        <br />    pack.putCards(player);        <br />  }        <br />  pack.putCards(pile);        <br />  return winner;        <br />}        <br /></pre></div><div><br /></div><div>One last thing. Let's take advantage of the reusable the Pack class to avoid creating a new one for every round. An improvement in memory use and nicer OO. A single Pack object is passed into the Game class and is reused for every round. Pack therefore becomes a dependency of Game and suddenly we have the possibility of playing a game with a different pack implementation, one with a reduced set of cards, for instance, or an alternative variant. Nice things like that happen when OO is done right :)</div><div><br /></div><div>Our Uno game model is now nearly complete. Out of interest we now have 48 tests and they run in milliseconds. That's good. Taking a look at the overall design it's quite good with a nice distribution of logic throughout the domain. There are a couple of "instanceof"s which I could probably refactor away. Overall a good design seems to have been driven out by the method.<br /><br />To complete the Uno project we need an application to run it (we have got this far basically with only unit tests!) preferably with the option of using human players. We'll do that now. As always we start with a test.<br /><blockquote class="tr_bq"><span style="color: blue;">Run a game of Uno with 4 of our random card players and print the result.</span></blockquote></div><div>This is very similar to the actual Game tests but I guess in reality this class does little more that the test harness. We should be testing the main() method which is the entry point to the actual app. Our test should look something like this:<br /><br /></div><pre class="brush:java">@Test<br />public void testPlayUnoGame() {<br />  PlayUno.main(new String[0]);<br />}<br /></pre><div><br /></div><div>But we have no assertions and since this is a static call to a fixed method we can't override any methods or pass any parameters. We'll have to capture the stdout. For that I use a little utility called Capture. Here's the test:<br /><br /><pre class="brush:java">@Test<br />public void testPlayUnoGame() throws IOException {<br />  try (Capture capture = new Capture()) {<br />    PlayUno.main(new String[0]);<br />    BufferedReader reader = capture.readBack();<br />    assertThat(reader.readLine()).matches("Player 0 scored \\d+ points.");<br />    assertThat(reader.readLine()).matches("Player 1 scored \\d+ points.");<br />    assertThat(reader.readLine()).matches("Player 2 scored \\d+ points.");<br />    assertThat(reader.readLine()).matches("Player 3 scored \\d+ points.");<br />    assertThat(reader.readLine()).matches("Player \\d is the winner.");<br />  }<br />}<br /></pre><br />This constitutes an acceptance test. Maybe we should have started with this right back at the beginning.<br /><br />That's the model done. Some takeaways:</div><br /><ol><li><b>Incremental testing is hard</b>, especially when adding functionality that necessarily spans several classes. In a rich domain model, functional tests will inevitably span domain objects and so will have to be broken down into multiple unit tests. That was the case, for example, in this post when scoring was introduced - the Round class and every card class had to be changed, test first.<br />&nbsp;</li><li>Even having developed the model from the beginning using pure TDD, I discovered&nbsp;<b>several flaws</b> that were not detected by the tests. I don't think these particular bugs would have happened (or lasted long) in a traditional code-&gt;test scenario because the failure would have been obvious. For example, reusing player instances introduced initialisation errors that somehow got past the tests, probably in a way related to the previous point. This is the main problem that I have with TDD at the moment. I think traditional testing, i.e. manual sanity checking, is still a necessity, at least for the time being.<br />&nbsp;</li><li>I expected to need a Hand class but in the end that has not been necessary. It would separate logic (Player) from data (Hand). TTD in this sense has had a positive impact on the design in the sense that an unnecessary class hasn't been created. On the other hand, it has driven out the CardHolder class, something that I would have probably designed anyway.<br />&nbsp;</li><li>Making the code testable has lead to a couple of <b>test artifacts in the code</b>. First the protected numCards() method in the end was necessary but earlier in the development it was added purely for test convenience. It doesn't really constitute breaking encapsulation but it isn't hiding as much information as it could. On the other hand the OOness of the design has been improved. Pushing logic out of the Round/Game classes into Pack and Pile made testing easier. I don't think that the Pile and Pack classes would have been such rich domain abstractions if I had designed it without TDD.<br /></li><li>On the other hand, having a rich domain means that game logic too is distributed around the model. That's OK until we want to play by different rules. For example my daughter (who introduced me to this game) doesn't play by the "official" rules on which I have based this model. According to her, you can play a Draw Two card on top of another Draw Two card to force the next player to pick up 4 cards. Making these kinds of changes to the rules with the current domain objects could be tricky. If I had designed the classes with this in mind would have made this easier.<br />&nbsp;</li><li>It should also be said that it took <b>much longer</b> to implement this model with TDD than in the traditional way. Having said that we have a solid code base and confidence when refactoring. That trade off exists and deciding it it's worth it should also be part of the TDD skill set.</li></ol><div><br /></div><div>It's not exactly state-of-the-art but it's been a good exercise in TDD and that was the objective.&nbsp;</div><div><br /></div><div>To complete the Uno game it is missing some important ingredients.<br /><br />First we should supply better Player implementations with more intelligent game strategies, at the moment the random selection of a valid card is just enough to get a valid game. We'll leave to creation of better players for another post where we'll consider better strategies and even use machine learning techniques to improve the game play.<br /><br />Secondly we should add a human UI, even if it's just a console based one for now. That'll be the next post.</div>