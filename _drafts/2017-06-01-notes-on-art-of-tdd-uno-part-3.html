---
layout: post
title: Notes on the Art of TDD - Uno (Part 3)
date: '2017-06-01T22:00:00.000+02:00'
author: John
tags:
- ood series
- tdd
modified_time: '2017-06-04T10:47:10.577+02:00'
blogger_id: tag:blogger.com,1999:blog-525051364647796957.post-8169991096469027570
blogger_orig_url: http://john-hearn.blogspot.com/2017/06/notes-on-art-of-tdd-uno-part-3.html
---

[Next day - continued from <a href="http://john-hearn.blogspot.com/2017/05/notes-on-art-of-tdd-uno-part-2.html" target="_blank">here</a>]<br /><br />The first test for the new requirement is straightforward, if a little contrived:<br /><br /><pre class="brush:java">@Test<br />public void testResetPack() throws Exception {<br />  Pack pack = new Pack();<br />  int numCardsInPack = pack.numCards();<br /><br />  Pile pile = new Pile();<br />  pile.addCard(new WildCard());<br />  pile.addCard(new WildCard());<br />  pile.addCard(new WildCard());<br /><br />  pack.resetPack(pile);<br /><br />  assertThat(pack.numCards()).isEqualTo(numCardsInPack + 3);<br />  assertThat(pile.numCards()).isEqualTo(0);<br />}<br /></pre><div><br /></div><div>The code is simple.</div><br /><pre class="brush:java">public void resetPack(Pile pile) {<br />  this.cards.addAll(pile.cards);<br />  pile.cards.clear();  <br />  this.shuffle();<br />}<br /></pre><div><br /></div><div>But how to test the game logic. This is a recurring theme of this exercise. The functionality is easy to test while the game logic is hard. This is the test I came up with:</div><div><br /></div><div><pre class="brush:java">@Test<br />public void testCardsFromPileAddedToPackWhenPackEmpty() throws Exception {        <br />  MockPack&nbsp;pack = new MockPack(17);        <br />  pile = new Pile();        <br />  players = new Player[] { new Player(), new MockPlayer(null) };        <br />  game = new UnoGame(pack, pile, players);        <br />  game.play();        <br />  assertThat(pack.count.get()).isGreaterThan(0);        <br />  assertThat(players[0].numCards()).isEqualTo(0);        <br />}        <br />        <br />private static class MockPack extends Pack {        <br />  AtomicInteger count = new AtomicInteger(0);        <br />        <br />  public MockPack(int numCards) {        <br />    cards.clear();        <br />    for (int i = 0; i &lt; numCards; i++) {        <br />      cards.add(new WildCard().withColour(Colour.BLUE));        <br />    }        <br />  }        <br />        <br />  @Override        <br />  public void resetPack(Pile pile) {        <br />    super.resetPack(pile);        <br />    count.incrementAndGet();        <br />  }        <br />}        <br /></pre></div><div><br /></div><div>It sets up a game situation which should result in the pile being moved to the stack and then uses a mock Pack implementation to ensure that the resetPack() method is indeed called. This seems brittle and overly complex. Maybe I should have tested all the logic this way from the beginning and then maybe I could have simplified the process more. Not sure.</div><div><br /></div><div>This is really getting close to a working Uno game now. All the card types are done and the logic is applied. A whole game can be played out. We're missing a few things like scoring and output which shouldn't be too difficult. However before doing that I've noticed we're occasionally getting the following error:</div><div><br /></div><div><div>java.lang.IndexOutOfBoundsException: Index: 0, Size: 0</div><div>at java.util.LinkedList.checkElementIndex(LinkedList.java:555)</div><div>at java.util.LinkedList.remove(LinkedList.java:525)</div><div>at project.Pack.drawCard(Pack.java:35)</div><div>at project.UnoGame.pickupCards(UnoGame.java:89)</div><div>at project.UnoGame.nextTurn(UnoGame.java:65)</div><div>at project.UnoGame.play(UnoGame.java:36)</div><div>at project.GameTest.testGame(GameTest.java:24)</div><div><br /></div></div>After some investigation it seems the above test did not catch the case where we're running out of cards in the pack while drawing because of a DrawTwo or WildFour card. In this case the resetPack() method should be called automatically. This has identified yet again that the tests only catch problems in the cases you have thought of, things that may have been picked up earlier by the traditional design-&gt;implement-&gt;test sequence. I think I can see how this happens. A branch in code should be tested by positive and negative tests. A second branch produces 4 possible combinations. A third branch 8 with only 6 tests. A fourth 16 with only 8 tests. You get the point. This has important consequences for algorithm development using TDD which I haven't seen mentioned by the TDD gurus.<br /><br />Anyway, to test this I'm going to fall back to the way we've been testing logic in this project, namely extracting a protected method. I don't like it but I'm not seeing the alternatives. Noticing we don't actually have a test for the drawCard() method on the Pack class (why not?), we create one first:<br /><br /><pre class="brush:java">@Test        <br />public void testDrawCard() throws Exception {        <br />  Pack pack = new Pack();        <br />  while (pack.numCards() &gt; 0) {        <br />    assertThat(pack.drawCard()).isNotNull();        <br />  }        <br />  assertThat(pack.drawCard()).isNull();        <br />}<br /></pre><div><br /></div>Ensuring drawCard() no longer throws an IndexOutOfBoundsException when the pack is empty. Then we test a new protected method on the game logic:<br /><br /><pre class="brush:java">@Test        <br />public void testResetPackOnDraw() throws Exception {        <br />  MockPack pack = new MockPack(50);        <br />  pile.addCard(pack.drawCard());        <br />  pile.addCard(pack.drawCard());        <br />  pile.addCard(pack.drawCard());        <br />  game = new UnoGame(pack, pile, players);        <br />  while (pack.numCards() &gt; 0) {        <br />    assertThat(game.drawCard()).isNotNull();        <br />  }        <br />  assertThat(pack.count.get()).isEqualTo(0);        <br />  assertThat(game.drawCard()).isNotNull();        <br />  assertThat(pack.count.get()).isEqualTo(1);        <br />}<br /></pre><div><br /></div><div>We've used the MockPack class again to verify that the resetPack() method has indeed been called. We also check that the protected method doesn't return null because the pack has been reset from the pile. The tests now pass every time. These last test cases seem very forced and they took a lot of time to develop... not only to determine what tests to write but I was even forced to debug the code to find the sources of the errors not picked up by the tests.&nbsp;<span style="color: #38761d; font-size: large;">Either TDD is very very hard or it actually has some pitfalls. Focusing on test cases can mean that your developer intuition is eroded</span>&nbsp;for example for corner cases and error scenarios.</div><div><br />We'll continue in the <a href="http://john-hearn.blogspot.com/2017/06/notes-on-art-of-tdd-uno-part-4.html" target="_blank">next part</a>.</div>