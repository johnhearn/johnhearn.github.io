<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building a QPU simulator in Clojure - Part 2</title>

  
  <meta name="description" content="Adding Neanderthal and complex numbers.">
  
  
  <meta name="keywords" content="quantum computing, tdd, clojure"/>
  
  
  <meta property="og:title" content="Building a QPU simulator in Clojure - Part 2">
  <meta property="og:type" content="note">
  <meta property="og:url" content="https://johnhearn.github.io//articles/building-a-qpu-simulator-in-clojure-part-2/">
  <meta property="og:image" content="https://johnhearn.github.io/">
  <meta property="og:description" content="Adding Neanderthal and complex numbers.">
  <meta property="og:site_name" content="John Hearn">
  
  <!-- Twitter cards -->
  <meta name="twitter:site"    content="@johnhearnbcn">
  <meta name="twitter:creator" content="@johnhearnbcn">
  <meta name="twitter:title"   content="Building a QPU simulator in Clojure - Part 2">

  
  <meta name="twitter:description" content="Adding Neanderthal and complex numbers.">
  

  
  <!-- end of Twitter cards -->

  <!-- Google Fonts loaded here depending on setting in _data/options.yml true loads font, blank does not-->
  
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
  
  <!-- Load up MathJax script if needed ... specify in /_data/options.yml file-->
  
      <script type="text/x-mathjax-config"> 
        MathJax.Ajax.config.path["Contrib"]="https://cdn.mathjax.org/mathjax/contrib"; 
        MathJax.Hub.Register.StartupHook("TeX Jax Ready",function (){MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{cancel: ["Extension","cancel"], bcancel: ["Extension","cancel"], xcancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]});}); 
        MathJax.Hub.Config({tex2jax:{inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true}, TeX:{equationNumbers:{autoNumber: "AMS"}, extensions: ["[Contrib]/physics/physics.js","[Contrib]/siunitx/siunitx.js"]}});
      </script>
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

  <link rel="stylesheet" type="text/css" href="/css/tufte.css">
  <!-- <link rel="stylesheet" type="text/css" href="/css/print.css" media="print"> -->

  <link rel="canonical" href="https://johnhearn.github.io//articles/building-a-qpu-simulator-in-clojure-part-2">

  <link rel="alternate" type="application/rss+xml" title="John Hearn" href="https://johnhearn.github.io//feed.xml" />
</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
  <nav class="group">
	  <a href="/">BLOG</a>
	  <a href="/notes.html">NOTES</a>
	  <a href="/about">ABOUT</a>
	</nav>
</header>
    <article class="group">
      <h1>Building a QPU simulator in Clojure - Part 2</h1>
<div class="subtitle">May 1, 2019</div>
<div class="smaller">six minutes.</div>

<p>In the <a href="building-a-qpu-simulator-in-clojure-part-1">last post</a> we simulated a single qubit and a couple of simple gates. Using those gates we could implement a trivial coin toss function and an 8-sided die. Now we’ll go on to incorporate the Neanderthal library before implementing more gates with complex matrices.</p>

<p>First let’s make the leap to Neanderthal so that it can do our matrix manipulations for us. It turns out to be quite straight forward. The first step is to add the dependency:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defproject</span><span class="w"> </span><span class="n">qucl</span><span class="w"> </span><span class="s">"0.1.0-SNAPSHOT"</span><span class="w">
  </span><span class="no">:dependencies</span><span class="w"> </span><span class="p">[[</span><span class="n">org.clojure/clojure</span><span class="w"> </span><span class="s">"1.10.0"</span><span class="p">]</span><span class="w">
                 </span><span class="p">[</span><span class="n">uncomplicate/neanderthal</span><span class="w"> </span><span class="s">"0.23.1"</span><span class="p">]]</span><span class="w">

  </span><span class="no">:exclusions</span><span class="w"> </span><span class="p">[[</span><span class="n">org.jcuda/jcuda-natives</span><span class="w"> </span><span class="no">:classifier</span><span class="w"> </span><span class="s">"apple-x86_64"</span><span class="p">]</span><span class="w">
               </span><span class="p">[</span><span class="n">org.jcuda/jcublas-natives</span><span class="w"> </span><span class="no">:classifier</span><span class="w"> </span><span class="s">"apple-x86_64"</span><span class="p">]])</span><span class="w">
</span></code></pre></div></div>

<p>A couple of the libraries required by Neandertal don’t have native builds for Mac in the standard repositories which gives us dependency errors. Since their not needed right now, we can safely exclude them.</p>

<p>To work with Neanderthal the Qubit will be a vector of floating point numbers <code class="language-plaintext highlighter-rouge">fv</code>, rather than a map. The choice of floats rather than doubles is deliberate, floats are faster but, more importantly, take up less memory than doubles and the exponential nature of quantum vectors means that quantum simulators tend to be memory bound.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">Qubit</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">fv</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="mf">0.0</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>For the measurement we’ll just use the first entry of the vector:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">prob-zero</span><span class="w"> </span><span class="p">[</span><span class="n">qubit</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">entry</span><span class="w"> </span><span class="n">qubit</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">entry</span><span class="w"> </span><span class="n">qubit</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>And for the gates we’ll use Neanderthal’s built-in matrix multiplication functions, in this case multiplying a dense matrix (created with the <code class="language-plaintext highlighter-rouge">fge</code> function) with the qubit vector using the <code class="language-plaintext highlighter-rouge">mv</code> function. For example or X gate becomes:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="p">[</span><span class="n">qubit</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">mv</span><span class="w"> </span><span class="p">(</span><span class="nf">fge</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="n">qubit</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>And the Hadamard gate is similar but scaling with the <em>in-place</em> <code class="language-plaintext highlighter-rouge">scal!</code> function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="p">[</span><span class="n">qubit</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">mv</span><span class="w"> </span><span class="p">(</span><span class="nf">scal!</span><span class="w"> </span><span class="n">oosr2</span><span class="w"> </span><span class="p">(</span><span class="nf">fge</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">-1</span><span class="p">]))</span><span class="w"> </span><span class="n">qubit</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>With these changes the tests continue to function without change and we’ve been able to remove own own linear algebra implementation and replace it with Neanderthal instead. Happy with that.</p>

<p>The next step is to build some more gates but for that we’ll need to use complex numbers. Essentially a quantum computing simulation is linear algebra using complex variables. Neanderthal is a fast and efficient linear algebra library but it uses doubles and floats as approximations of reals so we need a way to manipulate complex vectors and matrices. How can we use Neanderthal to do that? Well first note that a complex vector can be separated into real and imaginary parts. We can take a pair of matrices or vectors and store them in a simple map of real and imaginary values.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">complexify</span><span class="w">
  </span><span class="p">([</span><span class="n">real</span><span class="p">]</span><span class="w">
   </span><span class="p">{</span><span class="no">:real</span><span class="w"> </span><span class="n">real</span><span class="w"> </span><span class="no">:imag</span><span class="w"> </span><span class="p">(</span><span class="nf">zero</span><span class="w"> </span><span class="n">real</span><span class="p">)})</span><span class="w">
  </span><span class="p">([</span><span class="n">real</span><span class="w"> </span><span class="n">imag</span><span class="p">]</span><span class="w">
   </span><span class="p">{</span><span class="no">:real</span><span class="w"> </span><span class="n">real</span><span class="w"> </span><span class="no">:imag</span><span class="w"> </span><span class="n">imag</span><span class="p">}))</span><span class="w">
</span></code></pre></div></div>

<p>If we receive only one initial value then assume it’s the real part and set the imaginary part to zero. Once we have the separate real and imaginary values we can multiply, for example <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">x</code> like this:</p>

\[A x = (A_r + A_i i)(x_r + x_i i)
= (A_r x_r - A_i x_i) + (A_r x_i + A_i x_r) i\]

<p>In computational terms, that’s four floating point multiplications and three floating point additions. We can take advantage of Neanderthal’s compound add and multiply function <code class="language-plaintext highlighter-rouge">axpv</code> as well. Let’s see what that looks like in code:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">complex-mv</span><span class="w"> </span><span class="p">[</span><span class="n">A</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">complexify</span><span class="w"> </span><span class="p">(</span><span class="nf">axpy</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">(</span><span class="nf">mv</span><span class="w"> </span><span class="p">(</span><span class="no">:imag</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="no">:imag</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">mv</span><span class="w"> </span><span class="p">(</span><span class="no">:real</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="no">:real</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span><span class="w">
              </span><span class="p">(</span><span class="nf">axpy</span><span class="w"> </span><span class="p">(</span><span class="nf">mv</span><span class="w"> </span><span class="p">(</span><span class="no">:real</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="no">:imag</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">mv</span><span class="w"> </span><span class="p">(</span><span class="no">:imag</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="no">:real</span><span class="w"> </span><span class="n">x</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>A bit complicated but there is a lot of symmetry there. We use the new <code class="language-plaintext highlighter-rouge">complexify</code> function to convert the Qubit along with the H and X operators into complex valued functions:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">Qubit</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">complexify</span><span class="w"> </span><span class="p">(</span><span class="nf">fv</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="p">[</span><span class="n">qubit</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">complex-mv</span><span class="w"> </span><span class="p">(</span><span class="nf">complexify</span><span class="w"> </span><span class="p">(</span><span class="nf">fge</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="n">qubit</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="p">[</span><span class="n">qubit</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">complex-mv</span><span class="w"> </span><span class="p">(</span><span class="nf">complexify</span><span class="w"> </span><span class="p">(</span><span class="nf">scal!</span><span class="w"> </span><span class="n">oosr2</span><span class="w"> </span><span class="p">(</span><span class="nf">fge</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">-1</span><span class="p">])))</span><span class="w"> </span><span class="n">qubit</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Also the probability calculation must be adapted to calculate the absolute value of a complex number:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">sqr</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">prob-zero</span><span class="w"> </span><span class="p">[</span><span class="n">qubit</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nf">sqr</span><span class="w"> </span><span class="p">(</span><span class="nf">entry</span><span class="w"> </span><span class="p">(</span><span class="no">:real</span><span class="w"> </span><span class="n">qubit</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">sqr</span><span class="w"> </span><span class="p">(</span><span class="nf">entry</span><span class="w"> </span><span class="p">(</span><span class="no">:imag</span><span class="w"> </span><span class="n">qubit</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Our tests are passing again using the new complex implementation. So far so good. We’re now in a position to implement some other gates. But we have a problem. Neanderthal doesn’t have a mechanism for performing the Krondecker product and we’ll need that for creating the composite operators. Not sure what to do about that so I’m going to leave it there for now until I come up with a better plan ;)</p>



<div id="share-bar">

    <div class="share-buttons">
        Share this:
        <a  href="https://twitter.com/intent/tweet?text=Building a QPU simulator in Clojure - Part 2&url=https://johnhearn.github.io//articles/building-a-qpu-simulator-in-clojure-part-2"
            onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;"
            title="Share on Twitter" >
            <i class="fa-lg fab fa-twitter share-button"></i>
        </a>
        <a  href="https://www.linkedin.com/shareArticle?mini=true&url=https://johnhearn.github.io//articles/building-a-qpu-simulator-in-clojure-part-2&title=Building a QPU simulator in Clojure - Part 2&summary=Adding Neanderthal and complex numbers.&source=John Hearn"
            onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;"
            title="Share on LinkedIn" >
            <i class="fa-lg fab fa-linkedin share-button"></i>
        </a>
        <a  href="mailto:?subject=Building a QPU simulator in Clojure - Part 2&amp;body=Check out this site https://johnhearn.github.io//articles/building-a-qpu-simulator-in-clojure-part-2"
            title="Share via Email" >
            <i class="fa-lg fa fa-envelope-open share-button"></i>
        </a>
    </div>

</div>

    </article>
    <span class="print-footer">Building a QPU simulator in Clojure - Part 2 - May 1, 2019 - John Hearn</span>
    <footer>
  <hr class="slender">
  <ul class="footer-links">
    <li>
        <a href="https://twitter.com/johnhearnbcn">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
        </span>
        </a>
    </li>
    <li>
        <a href="https://github.com/johnhearn">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fab fa-github fa-stack-1x fa-inverse"></i>
        </span>
        </a>
    </li>
    <li>
        <a href="https://www.linkedin.com/in/john-hearn-599762b">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
        </span>
        </a>
    </li>
    <li>
        <a href="mailto:hearn.john@gmail.com">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope-open fa-stack-1x fa-inverse"></i>
        </span>
        </a>
    </li>
</ul>

<div class="credits">
<span>&copy; 2025 &nbsp;&nbsp;JOHN HEARN</span></br> <br>
<span>This site created with the <a href="//github.com/clayh53/tufte-jekyll">Tufte theme</a> for <a href="//jekyllrb.com">Jekyll</a>.</span> 
</div>  
</footer>
  </body>
</html>
