<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Grover's Algorithm in Yao.jl</title>

  
  <meta name="description" content="Implementing the simplest of the useful algorithms in Yao.jl">
  
  
  <meta name="keywords" content="quantum computing, julia, yao"/>
  
  
  <meta property="og:title" content="Grover&#39;s Algorithm in Yao.jl">
  <meta property="og:type" content="note">
  <meta property="og:url" content="https://johnhearn.github.io//articles/grovers-with-yao-jl/">
  <meta property="og:image" content="https://johnhearn.github.io/">
  <meta property="og:description" content="Implementing the simplest of the useful algorithms in Yao.jl">
  <meta property="og:site_name" content="John Hearn">
  
  <!-- Twitter cards -->
  <meta name="twitter:site"    content="@johnhearnbcn">
  <meta name="twitter:creator" content="@johnhearnbcn">
  <meta name="twitter:title"   content="Grover's Algorithm in Yao.jl">

  
  <meta name="twitter:description" content="Implementing the simplest of the useful algorithms in Yao.jl">
  

  
  <!-- end of Twitter cards -->

  <!-- Google Fonts loaded here depending on setting in _data/options.yml true loads font, blank does not-->
  
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
  
  <!-- Load up MathJax script if needed ... specify in /_data/options.yml file-->
  
      <script type="text/x-mathjax-config"> 
        MathJax.Ajax.config.path["Contrib"]="https://cdn.mathjax.org/mathjax/contrib"; 
        MathJax.Hub.Register.StartupHook("TeX Jax Ready",function (){MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{cancel: ["Extension","cancel"], bcancel: ["Extension","cancel"], xcancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]});}); 
        MathJax.Hub.Config({tex2jax:{inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true}, TeX:{equationNumbers:{autoNumber: "AMS"}, extensions: ["[Contrib]/physics/physics.js","[Contrib]/siunitx/siunitx.js"]}});
      </script>
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

  <link rel="stylesheet" type="text/css" href="/css/tufte.css">
  <!-- <link rel="stylesheet" type="text/css" href="/css/print.css" media="print"> -->

  <link rel="canonical" href="https://johnhearn.github.io//articles/grovers-with-yao-jl">

  <link rel="alternate" type="application/rss+xml" title="John Hearn" href="https://johnhearn.github.io//feed.xml" />
</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
  <nav class="group">
	  <a href="/">BLOG</a>
	  <a href="/notes.html">NOTES</a>
	  <a href="/about">ABOUT</a>
	</nav>
</header>
    <article class="group">
      <h1>Grover's Algorithm in Yao.jl</h1>
<div class="subtitle">July 25, 2020</div>
<div class="smaller">five minutes.</div>

<p>Continuing the series of posts building the basic quantum algorithms with <a href="https://github.com/QuantumBFS">Yao.jl</a> we come to Grover’s algorithm. There is a <a href="https://tutorials.yaoquantum.org/dev/generated/quick-start/3.grover-search/">tutorial on Grover</a> in the Yao.jl documentation <label for="qiskit" class="margin-toggle"> ⊕</label><input type="checkbox" id="qiskit" class="margin-toggle" /><span class="marginnote">QisKit also has a <a href="https://qiskit.org/textbook/ch-algorithms/grover.html">nice explication</a>. It’s worth getting multiple perspectives on these things. </span> but I found it a little hard to follow the code so I simplified it right down to the basics.</p>

<p><a href="grovers-search-algorithm">Remember</a> that we have a binary function, $f$, which is always equal $0$ except for a single value $u$, when it is equal to $1$. The challenge is to find $u$ with as few queries to $f$ as possible. As always, and with all the usual caveats, we take for granted that we have access to an oracle, $U_f$, that provides a suitable quantum transformation based on $f$.</p>

<p>The oracle consists of a transformation which reflects the target value, $u$, and only this value, around the x-axis. All other values are left untouched.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> oracle</span><span class="x">(</span><span class="n">u</span><span class="o">::</span><span class="n">T</span><span class="x">)</span> <span class="k">where</span> <span class="n">T</span><span class="o">&lt;:</span><span class="kt">Unsigned</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ceil</span><span class="x">(</span><span class="kt">Int</span><span class="x">,</span> <span class="n">log</span><span class="x">(</span><span class="mi">2</span><span class="x">,</span> <span class="n">u</span><span class="x">))</span> <span class="c"># Use only as many bits as necessary</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">ones</span><span class="x">(</span><span class="kt">ComplexF64</span><span class="x">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="x">)</span>
    <span class="n">v</span><span class="x">[</span><span class="n">u</span><span class="o">+</span><span class="mi">1</span><span class="x">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span> <span class="c"># Flip the value we're looking for</span>
    <span class="kt">Diagonal</span><span class="x">(</span><span class="n">v</span><span class="x">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We work out the smallest number of bits needed from the value itself. In the Yao.jl tutorial this is all on one line and quite cryptic, hopefully this version is easier to read.</p>

<p>In the tutorial they use the phased version of the diffusion operator<label for="yaodraw" class="margin-toggle"> ⊕</label><input type="checkbox" id="yaodraw" class="margin-toggle" /><span class="marginnote">This diagram is generated directly from the code with YaoDraw :) </span>:</p>

<p><img src="/assets/images/quantum-computing/grovers-circuit-phase.png" alt="grovers-circuit" width="400px" /></p>

<p>Notice that with this construction we don’t have to use an ancillary bit. As can be seen in the diagram we also have some reusable blocks, namely the $H^{\otimes n}$, which for some reason the tutorial calls <code class="language-plaintext highlighter-rouge">gen</code>, and the repeating section which is a combination of the oracle itself followed by the diffusion operator. They are chained together like this:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">gen</span> <span class="o">=</span> <span class="n">repeat</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">H</span><span class="x">)</span>
    <span class="n">reflect0</span> <span class="o">=</span> <span class="n">control</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="o">-</span><span class="n">collect</span><span class="x">(</span><span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="x">),</span> <span class="n">n</span><span class="o">=&gt;-</span><span class="n">Z</span><span class="x">)</span> <span class="c"># I-2|0&gt;&lt;0|</span>
    <span class="n">repeating_circuit</span> <span class="o">=</span> <span class="n">chain</span><span class="x">(</span><span class="n">Uf</span><span class="x">,</span> <span class="n">gen</span><span class="x">,</span> <span class="n">reflect0</span><span class="x">,</span> <span class="n">gen</span><span class="x">)</span>
</code></pre></div></div>

<p>Inside the repeating section there is also the reflection circuit, <code class="language-plaintext highlighter-rouge">reflect0</code> which is responsible for flipping the distribution about the average value which is what has the effect of amplifying values made negative by the oracle. To check that it is indeed the correct circuit it can be compared to the other form \(I_n - 2\vert 0^n \rangle \langle 0^n \vert\).</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ZERO</span><span class="x">(</span><span class="n">n</span><span class="x">)</span> <span class="o">=</span> <span class="n">foldl</span><span class="x">(</span><span class="n">kron</span><span class="x">,</span> <span class="n">fill</span><span class="x">([</span><span class="mi">1</span><span class="x">,</span> <span class="mi">0</span><span class="x">],</span> <span class="n">n</span><span class="x">))</span>
<span class="kt">Int</span><span class="o">.</span><span class="x">(</span><span class="n">real</span><span class="o">.</span><span class="x">(</span><span class="n">sparse</span><span class="x">(</span><span class="n">I</span><span class="x">,</span> <span class="mi">16</span><span class="x">,</span> <span class="mi">16</span><span class="x">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">ZERO</span><span class="x">(</span><span class="mi">4</span><span class="x">)</span><span class="o">*</span><span class="n">ZERO</span><span class="x">(</span><span class="mi">4</span><span class="x">)</span><span class="err">'</span><span class="x">))</span>
</code></pre></div></div>

<p>It is indeed the same, although I’m still sure of the origin of the conditional <code class="language-plaintext highlighter-rouge">Z</code> transform version, it’s an identity to bear in mind.</p>

<p>Continuing with the algorithm, the repeating section is simply placed in a for loop applied to a prepared quantum register:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">reg</span> <span class="o">=</span> <span class="n">zero_state</span><span class="x">(</span><span class="n">n</span><span class="x">)</span> <span class="o">|&gt;</span> <span class="n">gen</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">iter</span>
        <span class="n">reg</span> <span class="o">|&gt;</span> <span class="n">repeating_circuit</span>
    <span class="k">end</span>
</code></pre></div></div>

<p>The variable <code class="language-plaintext highlighter-rouge">iter</code> is the number of iterations we want to apply. Getting the right value for this is tricky<label for="iter" class="margin-toggle"> ⊕</label><input type="checkbox" id="iter" class="margin-toggle" /><span class="marginnote">The tutorial has much more sophisticated way of doing this. </span> so we just use a hand picked value for now. It should be less than $\sqrt{2^n}$. For clarity we wrap the whole circuit in a function and pass in the oracle:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> grovers</span><span class="x">(</span><span class="n">Uf</span><span class="o">::</span><span class="n">AbstractBlock</span><span class="x">{</span><span class="n">n</span><span class="x">},</span> <span class="n">iter</span><span class="o">::</span><span class="kt">Int</span><span class="x">)</span> <span class="k">where</span> <span class="n">n</span>
<span class="o">...</span>
<span class="k">end</span>
<span class="n">grovers</span><span class="x">(</span><span class="n">matblock</span><span class="x">(</span><span class="n">oracle</span><span class="x">(</span><span class="mb">0b11110011</span><span class="x">)),</span> <span class="mi">10</span><span class="x">)</span> <span class="o">|&gt;</span> <span class="n">measure!</span>
</code></pre></div></div>

<p>And that’s it, not too bad actually. Working code is <a href="https://nbviewer.jupyter.org/github/johnhearn/notebooks/blob/master/QuantumComputing/Grover%27s%20Algorithm%20in%20Yao.jl.ipynb">here</a>.</p>

<p>Looking forward to applying to more <a href="https://www.youtube.com/watch?v=afuoGbptET8">interesting problems</a> to it.</p>

<hr />

<p>PS: Just for fun this is how the histogram of probabilities evolves between each iteration. It’s clear how the chosen value emerges in just a few steps.</p>

<p><img src="/assets/images/quantum-computing/grovers-search-anim.gif" alt="grovers-search" /></p>

<p>If you’re interested, this is the code to generate the histogram. Run with 6 bits over 6 iterations and 1000 shots at each iteration to get the probability.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">Plots</span>
<span class="o">...</span>
  <span class="n">anim</span> <span class="o">=</span> <span class="nd">@animate</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">iter</span>
    <span class="n">numbers</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">|&gt;</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">measure</span><span class="x">(</span><span class="n">r</span><span class="x">,</span> <span class="n">nshots</span><span class="o">=</span><span class="mi">1000</span><span class="x">)</span> <span class="o">.|&gt;</span> <span class="n">bint</span>
    <span class="n">histogram</span><span class="x">(</span><span class="n">numbers</span><span class="x">,</span> <span class="n">normed</span><span class="o">=</span><span class="nb">true</span><span class="x">,</span> <span class="n">legend</span><span class="o">=:</span><span class="n">none</span><span class="x">,</span> <span class="n">xlims</span><span class="o">=</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span><span class="mi">63</span><span class="x">),</span> <span class="n">ylims</span><span class="o">=</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span><span class="mi">1</span><span class="x">),</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">64</span><span class="x">)</span>
    <span class="n">reg</span> <span class="o">|&gt;</span> <span class="n">repeating_circuit</span>
  <span class="k">end</span>
<span class="o">...</span>
<span class="n">gif</span><span class="x">(</span><span class="n">anim</span><span class="x">,</span> <span class="s">"grovers-search.gif"</span><span class="x">,</span> <span class="n">fps</span> <span class="o">=</span> <span class="mi">1</span><span class="x">)</span>
</code></pre></div></div>



<div id="share-bar">

    <div class="share-buttons">
        Share this:
        <a  href="https://twitter.com/intent/tweet?text=Grover's Algorithm in Yao.jl&url=https://johnhearn.github.io//articles/grovers-with-yao-jl"
            onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;"
            title="Share on Twitter" >
            <i class="fa-lg fab fa-twitter share-button"></i>
        </a>
        <a  href="https://www.linkedin.com/shareArticle?mini=true&url=https://johnhearn.github.io//articles/grovers-with-yao-jl&title=Grover's Algorithm in Yao.jl&summary=Implementing the simplest of the useful algorithms in Yao.jl&source=John Hearn"
            onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;"
            title="Share on LinkedIn" >
            <i class="fa-lg fab fa-linkedin share-button"></i>
        </a>
        <a  href="mailto:?subject=Grover's Algorithm in Yao.jl&amp;body=Check out this site https://johnhearn.github.io//articles/grovers-with-yao-jl"
            title="Share via Email" >
            <i class="fa-lg fa fa-envelope-open share-button"></i>
        </a>
    </div>

</div>

    </article>
    <span class="print-footer">Grover's Algorithm in Yao.jl - July 25, 2020 - John Hearn</span>
    <footer>
  <hr class="slender">
  <ul class="footer-links">
    <li>
        <a href="https://twitter.com/johnhearnbcn">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
        </span>
        </a>
    </li>
    <li>
        <a href="https://github.com/johnhearn">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fab fa-github fa-stack-1x fa-inverse"></i>
        </span>
        </a>
    </li>
    <li>
        <a href="https://www.linkedin.com/in/john-hearn-599762b">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
        </span>
        </a>
    </li>
    <li>
        <a href="mailto:hearn.john@gmail.com">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope-open fa-stack-1x fa-inverse"></i>
        </span>
        </a>
    </li>
</ul>

<div class="credits">
<span>&copy; 2025 &nbsp;&nbsp;JOHN HEARN</span></br> <br>
<span>This site created with the <a href="//github.com/clayh53/tufte-jekyll">Tufte theme</a> for <a href="//jekyllrb.com">Jekyll</a>.</span> 
</div>  
</footer>
  </body>
</html>
