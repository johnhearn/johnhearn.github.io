<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building a QPU simulator in Julia - Part 2</title>

  
  <meta name="description" content="Starting again with Julia.">
  
  
  <meta name="keywords" content="quantum computing, tdd, julia"/>
  
  
  <meta property="og:title" content="Building a QPU simulator in Julia - Part 2">
  <meta property="og:type" content="note">
  <meta property="og:url" content="https://johnhearn.github.io//articles/building-a-qpu-simulator-in-julia-part-2/">
  <meta property="og:image" content="https://johnhearn.github.io/">
  <meta property="og:description" content="Starting again with Julia.">
  <meta property="og:site_name" content="John Hearn">
  
  <!-- Twitter cards -->
  <meta name="twitter:site"    content="@johnhearnbcn">
  <meta name="twitter:creator" content="@johnhearnbcn">
  <meta name="twitter:title"   content="Building a QPU simulator in Julia - Part 2">

  
  <meta name="twitter:description" content="Starting again with Julia.">
  

  
  <!-- end of Twitter cards -->

  <!-- Google Fonts loaded here depending on setting in _data/options.yml true loads font, blank does not-->
  
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
  
  <!-- Load up MathJax script if needed ... specify in /_data/options.yml file-->
  
      <script type="text/x-mathjax-config"> 
        MathJax.Ajax.config.path["Contrib"]="https://cdn.mathjax.org/mathjax/contrib"; 
        MathJax.Hub.Register.StartupHook("TeX Jax Ready",function (){MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{cancel: ["Extension","cancel"], bcancel: ["Extension","cancel"], xcancel: ["Extension","cancel"], cancelto: ["Extension","cancel"]});}); 
        MathJax.Hub.Config({tex2jax:{inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true}, TeX:{equationNumbers:{autoNumber: "AMS"}, extensions: ["[Contrib]/physics/physics.js","[Contrib]/siunitx/siunitx.js"]}});
      </script>
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

  <link rel="stylesheet" type="text/css" href="/css/tufte.css">
  <!-- <link rel="stylesheet" type="text/css" href="/css/print.css" media="print"> -->

  <link rel="canonical" href="https://johnhearn.github.io//articles/building-a-qpu-simulator-in-julia-part-2">

  <link rel="alternate" type="application/rss+xml" title="John Hearn" href="https://johnhearn.github.io//feed.xml" />
</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
  <nav class="group">
	  <a href="/">BLOG</a>
	  <a href="/notes.html">NOTES</a>
	  <a href="/about">ABOUT</a>
	</nav>
</header>
    <article class="group">
      <h1>Building a QPU simulator in Julia - Part 2</h1>
<div class="subtitle">May 7, 2019</div>
<div class="smaller">16 minutes.</div>

<p>In the <a href="building-a-qpu-simulator-in-julia-part-1">last post</a> we saw how the Julia programming language has several advantages over Kotlin and Clojure for building a quantum computer simulator. This post covers how we might do that<label for="maths" class="margin-toggle sidenote-number"></label><input type="checkbox" id="maths" class="margin-toggle" /><span class="sidenote">Note: These notes go into some pretty heavy maths. For a less mathematical description of quantum computing concepts, take a look at <a href="quantum-computing-primer-part-1a">this article</a>. </span>. We’ll start as <a href="building-a-qpu-simulator-in-clojure-part-1">before</a> with a simple case of an 8-sided <a href="quantum-random-number-generator">quantum die</a>. This is the code written with the <a href="https://github.com/johnhearn/quko">Quko</a> library (from the <a href="https://github.com/johnhearn/quko">README</a>):</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">qubits</span> <span class="p">=</span> <span class="nc">Qubits</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nf">hadamard</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">qubits</span><span class="p">.</span><span class="nf">measureAll</span><span class="p">().</span><span class="nf">toInt</span><span class="p">())</span>
</code></pre></div></div>

<p>Written in Julia this becomes:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">qubits</span> <span class="o">=</span> <span class="n">hadamard</span><span class="x">(</span><span class="n">qubits</span><span class="x">(</span><span class="mi">3</span><span class="x">),</span> <span class="mi">1</span><span class="o">:</span><span class="mi">3</span><span class="x">)</span>
<span class="n">print</span><span class="x">(</span><span class="n">toInt</span><span class="x">(</span><span class="n">measureAll</span><span class="x">(</span><span class="n">qubits</span><span class="x">))</span>
</code></pre></div></div>

<p>Some things to notice. Firstly we’ve moved to a functional style. As typing is optional there is no need to define the variable. Also the range specified by <code class="language-plaintext highlighter-rouge">1:3</code> is using <a href="https://craftofcoding.wordpress.com/2017/03/12/why-1-based-indexing-is-ok/">1-based indexing</a>.</p>

<h2 id="measurement-of-single-qubit">Measurement of Single Qubit</h2>

<p>We’ll define a test to verify the probability that our qubit is measured <code class="language-plaintext highlighter-rouge">false</code>.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">repeatedly</span> <span class="o">=</span> <span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">f</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="n">map</span><span class="x">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="x">(),</span> <span class="n">collect</span><span class="x">(</span><span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="x">))</span>
<span class="n">sample</span> <span class="o">=</span> <span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">f</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="n">count</span><span class="x">(</span><span class="n">repeatedly</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">f</span><span class="x">))</span>

<span class="nd">@test</span> <span class="n">sample</span><span class="x">(</span><span class="mi">1000</span><span class="x">,</span> <span class="x">()</span> <span class="o">-&gt;</span> <span class="n">measure</span><span class="x">(</span><span class="n">qubit</span><span class="x">()))</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div>

<p>As <a href="building-a-qpu-simulator-in-clojure-part-1">before</a>, we can make that pass trivially, of course, defining a dummy qubit and just returning false from <code class="language-plaintext highlighter-rouge">measure</code> every time.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">qubit</span> <span class="o">=</span> <span class="x">()</span> <span class="o">-&gt;</span> <span class="nb">nothing</span>
<span class="n">measure</span> <span class="o">=</span> <span class="x">(</span><span class="n">qubit</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="nb">false</span>
</code></pre></div></div>

<p>Now, given Julia’s support for matrices, let’s jump straight to theory. A qubit can be represented by a <strong>pair</strong> of (complex) numbers, a \(\mathcal{H}_2\) space. In the case of a qubit initialised to the \(\ket{0}\) state that is just <code class="language-plaintext highlighter-rouge">[1 0]</code>. We saw in the <a href="building-a-qpu-simulator-in-julia-part-1">last post</a> how easy that is in Julia<label for="float32" class="margin-toggle sidenote-number"></label><input type="checkbox" id="float32" class="margin-toggle" /><span class="sidenote">Julia uses 64-bit floats by default. We don’t need that level of precision and 32-bit floats save memory, a simple but important consideration for QPU simulators. </span>:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">qubit</span> <span class="o">=</span> <span class="x">()</span> <span class="o">-&gt;</span> <span class="kt">Float32</span><span class="x">(</span><span class="mi">1</span><span class="x">)</span> <span class="o">*</span> <span class="x">[</span><span class="mi">1</span><span class="x">,</span> <span class="mi">0</span><span class="x">]</span>
</code></pre></div></div>

<p>The measurement can be represented by a matrix operator using the quadratic form \(p(\ket{0})=\braket{v}{0}\braket{0}{v}=v^{T} M_0 v\) where \(p(\ket{0})\) is the probability that a qubit is measured as <code class="language-plaintext highlighter-rouge">false</code> and</p>

\[M_0 = \ketbra{0}{0} = \left(
  \begin{array}{c} 
  1 \\ 
  0 \\
  \end{array} 
  \right)
  \left(
  \begin{array}{c} 
  1 &amp; 0
  \end{array} 
  \right)
  =
  \left(
  \begin{array}{c} 
  1 &amp; 0 \\ 
  0 &amp; 0 \\
  \end{array} 
  \right)\]

<p>To make this calculation we can take advantage of Julia’s <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#Base.adjoint">adjoint</a> operator, <code class="language-plaintext highlighter-rouge">'</code>. Also this is where the random aspect of the qubit comes into play and the <code class="language-plaintext highlighter-rouge">rand()</code> function is used to determine if the measurement is indeed <code class="language-plaintext highlighter-rouge">false</code> based on the probability of it being so.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">M₀</span><span class="o">=</span><span class="x">[</span><span class="mi">1</span> <span class="mi">0</span><span class="x">]</span><span class="err">'</span> <span class="o">*</span> <span class="x">[</span><span class="mi">1</span> <span class="mi">0</span><span class="x">]</span>
<span class="n">measure</span> <span class="o">=</span> <span class="x">(</span><span class="n">qubit</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="n">rand</span><span class="x">()</span> <span class="o">&lt;</span> <span class="n">abs</span><span class="x">(</span><span class="n">q</span><span class="err">'</span> <span class="o">*</span> <span class="n">M₀</span> <span class="o">*</span> <span class="n">q</span><span class="x">)</span>
</code></pre></div></div>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">julia&gt;</span><span class="w"> </span>@test sample<span class="o">(</span>1_000_000, <span class="o">()</span> -&gt; measure<span class="o">(</span>qubit<span class="o">()))</span> <span class="o">==</span> 0
<span class="go">Test Passed
</span></code></pre></div></div>

<h2 id="the-hadamard-gate">The Hadamard Gate</h2>

<p>At the moment the qubit is always initialised to \(\ket{0}\) so measurement will always return <code class="language-plaintext highlighter-rouge">false</code> with 100% probability. To make the measurement more meaningful we want to be able to move the state of the qubit into a 50/50 superposition (half way around the Bloch sphere) so that measurement will return <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code> with equal probability, a fair coin toss. We can do that using the Hadamard operator. The Hadamard operator is defined as \(H = \frac{1}{\sqrt{2}} \left(
  \begin{array}{c} 
  1 &amp; 1 \\
  1 &amp; -1 \\
  \end{array} 
  \right)\) and is similarly easy to implement with Julia’s matrix syntax:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">julia&gt;</span><span class="w"> </span>H <span class="o">=</span> Float32<span class="o">(</span>1/sqrt<span class="o">(</span>2<span class="o">))</span> <span class="k">*</span> <span class="o">[</span>1 1<span class="p">;</span> 1 <span class="nt">-1</span><span class="o">]</span>
<span class="go">2×2 Array{Float32,2}:
 0.707107   0.707107
 0.707107  -0.707107

</span><span class="gp">julia&gt;</span><span class="w"> </span>hadamard <span class="o">=</span> <span class="o">(</span>qubit<span class="o">)</span> -&gt; H <span class="k">*</span> qubit
<span class="gp">julia&gt;</span><span class="w"> </span>hadamard<span class="o">(</span>qubit<span class="o">())</span>
<span class="go">2-element Array{Float32,1}:
 0.70710677
 0.70710677
</span></code></pre></div></div>

<p>Or even better using the piping operator:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">julia&gt;</span><span class="w"> </span>qubit<span class="o">()</span> |&gt; hadamard
<span class="go">2-element Array{Float32,1}:
 0.70710677
 0.70710677
</span></code></pre></div></div>

<p>Then we can measure our qubit and it gives us one random bit each time, as can be seen by measuring multiple qubits prepared in the same way.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">julia&gt;</span><span class="w"> </span>repeatedly<span class="o">(</span>3, <span class="o">()</span> -&gt; qubit<span class="o">()</span> |&gt; hadamard |&gt; measure<span class="o">)</span>
<span class="go">10-element Array{Bool,1}:
 false
  true
 false
</span></code></pre></div></div>

<p>We could build our random number generator already, taking 3 independent measurements and interpreting it as binary. For example,</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">coinToss</span> <span class="o">=</span> <span class="x">()</span> <span class="o">-&gt;</span> <span class="x">()</span> <span class="o">-&gt;</span> <span class="n">qubit</span><span class="x">()</span> <span class="o">|&gt;</span> <span class="n">hadamard</span> <span class="o">|&gt;</span> <span class="n">measure</span>
<span class="n">toInt</span> <span class="o">=</span> <span class="x">(</span><span class="n">b</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="n">reduce</span><span class="x">((</span><span class="n">acc</span><span class="x">,</span> <span class="n">v</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">acc</span> <span class="o">+</span> <span class="n">v</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="x">,</span> <span class="n">b</span><span class="x">)</span>
</code></pre></div></div>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">julia&gt;</span><span class="w"> </span>toInt<span class="o">(</span>repeatedly<span class="o">(</span>3, coinToss<span class="o">))</span>
<span class="go">6
</span><span class="gp">julia&gt;</span><span class="w"> </span>toInt<span class="o">(</span>repeatedly<span class="o">(</span>3, coinToss<span class="o">))</span>
<span class="go">3
</span></code></pre></div></div>

<p>This, however, is cheating because we can only deal with one qubit at a time and it doesn’t implement our original feature test. We’re back to the same point as we were with the Clojure implementation but in a better position because now we can take advantage of more of Julia’s built-in linear algebra support.</p>

<h2 id="quantum-registers">Quantum Registers</h2>

<p>So let’s make things even harder and represent qubit <em>registers</em>. Registers are <em>systems</em> of qubits in a combined state. We calculate this combined state with the <a href="https://en.wikipedia.org/wiki/Kronecker_product">Krondecker</a> product, also implemented natively in Julia by the <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/index.html#Base.kron"><code class="language-plaintext highlighter-rouge">kron</code></a> function. Let’s try a 2 qubit register:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">qubits</span> <span class="o">=</span> <span class="x">()</span> <span class="o">-&gt;</span> <span class="n">kron</span><span class="x">(</span><span class="n">qubit</span><span class="x">(),</span> <span class="n">qubit</span><span class="x">())</span>
</code></pre></div></div>

<p>Testing in the console, it just works…</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">julia&gt;</span><span class="w"> </span>qubits<span class="o">()</span>
<span class="go">4-element Array{Float32,1}:
 1.0
 0.0
 0.0
 0.0
</span></code></pre></div></div>

<p>We can generate any size register we please, with the only constraint being available memory:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">register</span> <span class="o">=</span> <span class="x">(</span><span class="n">n</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="n">foldl</span><span class="x">(</span><span class="n">kron</span><span class="x">,</span> <span class="n">fill</span><span class="x">(</span><span class="n">qubit</span><span class="x">(),</span> <span class="n">n</span><span class="x">))</span>
</code></pre></div></div>

<p>This function uses the standard <code class="language-plaintext highlighter-rouge">fold</code> function to perform the <code class="language-plaintext highlighter-rouge">kron</code> operation, from left to right, over an array of <code class="language-plaintext highlighter-rouge">n</code> qubits.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">julia&gt;</span><span class="w"> </span>register<span class="o">(</span>3<span class="o">)</span>
<span class="go">8-element Array{Float32,1}:
 1.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
</span></code></pre></div></div>

<p>It works as expected. A 2 bit register needs an array of 4 complex numbers, a 3 bit one needs an 8 bit array, 4-bits require 16 and so on. The size of the array gets very big.</p>

<p>Now we can turn our attention to the quantum gates and combine them into a multiple qubit gate. Once again the Krondecker product is used and works in exactly the same way.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hadamard</span> <span class="o">=</span> <span class="x">(</span><span class="n">n</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="n">foldl</span><span class="x">(</span><span class="n">kron</span><span class="x">,</span> <span class="n">fill</span><span class="x">(</span><span class="n">H</span><span class="x">,</span> <span class="n">n</span><span class="x">))</span>
</code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">julia&gt;</span><span class="w"> </span>hadamard<span class="o">(</span>3<span class="o">)</span>
<span class="go">8×8 Array{Float32,2}:
 0.353553   0.353553   0.353553   0.353553   0.353553   0.353553   0.353553   0.353553
 0.353553  -0.353553   0.353553  -0.353553   0.353553  -0.353553   0.353553  -0.353553
 0.353553   0.353553  -0.353553  -0.353553   0.353553   0.353553  -0.353553  -0.353553
 0.353553  -0.353553  -0.353553   0.353553   0.353553  -0.353553  -0.353553   0.353553
 0.353553   0.353553   0.353553   0.353553  -0.353553  -0.353553  -0.353553  -0.353553
 0.353553  -0.353553   0.353553  -0.353553  -0.353553   0.353553  -0.353553   0.353553
 0.353553   0.353553  -0.353553  -0.353553  -0.353553  -0.353553   0.353553   0.353553
 0.353553  -0.353553  -0.353553   0.353553  -0.353553   0.353553   0.353553  -0.353553
</span></code></pre></div></div>

<p>It’s clear how the size of these gates gets out of hand very quickly having a size of \(2^n \times 2^n\).</p>

<p>Using this gate we can apply the Hadamard operator to all the qubits at once.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">julia&gt;</span><span class="w"> </span>hadamard<span class="o">(</span>3<span class="o">)</span> <span class="k">*</span> register<span class="o">(</span>3<span class="o">)</span>
<span class="go">8-element Array{Float32,1}:
 0.35355335
 0.35355335
 0.35355335
 0.35355335
 0.35355335
 0.35355335
 0.35355335
 0.35355335
</span></code></pre></div></div>

<p>This is the combined state of a 3 bit quantum register with each bit in a 50/50 superposition. Not to be confused with entanglement because the bits are still independent… so far.</p>

<p>This is where things get a little more tricky.  To measure a single qubit we need to place the measurement operator over the qubit in the register, applying the identity operator for all other bits. This is called lifting<label for="lifting" class="margin-toggle sidenote-number"></label><input type="checkbox" id="lifting" class="margin-toggle" /><span class="sidenote">At least it’s called lifting in <a href="https://arxiv.org/abs/1608.03355">this paper</a> which I found helpful to understand this process. </span>.</p>

<p>We’ll need the identity operator for a single qubit \(I = \left(
  \begin{array}{c} 
  1 &amp; 0 \\
  0 &amp; 1 \\
  \end{array} 
  \right)\):</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eye</span> <span class="o">=</span> <span class="x">()</span> <span class="o">-&gt;</span> <span class="kt">Matrix</span><span class="x">{</span><span class="kt">Float32</span><span class="x">}(</span><span class="n">I</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">2</span><span class="x">)</span>
</code></pre></div></div>

<p>Now we must <em>lift</em> the \(M_0\) operator as \(I^{k-1} \times M_0 \times I^{n-k-1}\). In Julia this can be written like this:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lift</span> <span class="o">=</span> <span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">k</span><span class="x">,</span> <span class="n">op</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="n">foldl</span><span class="x">(</span><span class="n">kron</span><span class="x">,</span> <span class="n">map</span><span class="x">(</span><span class="n">it</span> <span class="o">-&gt;</span> <span class="x">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">k</span><span class="x">)</span> <span class="o">?</span> <span class="n">op</span> <span class="o">:</span> <span class="n">eye</span><span class="x">,</span> <span class="n">collect</span><span class="x">(</span><span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="x">)))</span>
</code></pre></div></div>

<p>This function will combine a series of \(I\) operators, the <code class="language-plaintext highlighter-rouge">op</code> operator over the <code class="language-plaintext highlighter-rouge">k</code>th bit and then more \(I\) operators to the end of the register. The result is<label for="sparse" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sparse" class="margin-toggle" /><span class="sidenote">It can be seen here that the lifting matrix is mostly full of zeros. Hopefully we’ll be able to take advantage of Julia’s specialised matrix representations to optimise this. </span>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">julia&gt;</span><span class="w"> </span>lift<span class="o">(</span>3, 2, M₀<span class="o">)</span>
<span class="go">8×8 Array{Float32,2}:
 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
</span></code></pre></div></div>

<p>Measurement of the kth bit is then:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">measure</span> <span class="o">=</span> <span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">k</span><span class="x">,</span> <span class="n">qubits</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="n">rand</span><span class="x">()</span> <span class="o">&gt;</span> <span class="n">qubits</span><span class="err">'</span> <span class="o">*</span> <span class="n">lift</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">k</span><span class="x">,</span> <span class="n">M₀</span><span class="x">)</span> <span class="o">*</span> <span class="n">qubits</span>
</code></pre></div></div>

<p>So we can measure the 2nd bit like this:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">julia&gt;</span><span class="w"> </span>qubits <span class="o">=</span> hadamard<span class="o">(</span>3<span class="o">)</span> <span class="k">*</span> register<span class="o">(</span>3<span class="o">)</span>
<span class="c">...
</span><span class="gp">julia&gt;</span><span class="w"> </span>measure<span class="o">(</span>3, 2, qubits<span class="o">)</span>
<span class="go">true
</span></code></pre></div></div>

<p>One more important point. The measurement of each qubit is an operation which <em>collapses</em> the state of the qubit, i.e. changes its value. The measurement function must <em>lift</em> the \(M_0\) or \(M_1\) operation (depending on the result) over the measured qubit, apply it to the register and then renormalise it. More information about this can be found in <a href="https://arxiv.org/abs/1608.03355">this paper</a>.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">M₁</span> <span class="o">=</span> <span class="x">[</span><span class="mi">0</span> <span class="mi">1</span><span class="x">]</span><span class="err">'</span> <span class="o">*</span> <span class="x">[</span><span class="mi">0</span> <span class="mi">1</span><span class="x">]</span>
<span class="n">measure</span> <span class="o">=</span> <span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">k</span><span class="x">,</span> <span class="n">qubits</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="k">begin</span>
       <span class="n">result</span> <span class="o">=</span> <span class="n">rand</span><span class="x">()</span> <span class="o">&gt;</span> <span class="n">qubits</span><span class="err">'</span> <span class="o">*</span> <span class="n">lift</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">k</span><span class="x">,</span> <span class="n">M₀</span><span class="x">)</span> <span class="o">*</span> <span class="n">qubits</span>
       <span class="x">(</span><span class="n">result</span><span class="x">,</span> <span class="n">normalize</span><span class="x">(</span><span class="n">lift</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">k</span><span class="x">,</span> <span class="x">(</span><span class="n">result</span> <span class="o">?</span> <span class="n">M₁</span> <span class="o">:</span> <span class="n">M₀</span><span class="x">))</span> <span class="o">*</span> <span class="n">qubits</span><span class="x">))</span>
<span class="k">end</span>
</code></pre></div></div>

<p>To measure all the bits at once we can do something like this:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">measureAll</span> <span class="o">=</span> <span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">qubits</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="k">begin</span>
         <span class="n">results</span> <span class="o">=</span> <span class="x">[];</span> 
         <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
           <span class="n">result</span><span class="x">,</span> <span class="n">qubits</span> <span class="o">=</span> <span class="n">measure</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">k</span><span class="x">,</span> <span class="n">qubits</span><span class="x">)</span>
           <span class="n">push!</span><span class="x">(</span><span class="n">results</span><span class="x">,</span> <span class="n">result</span><span class="x">)</span>
         <span class="k">end</span>
         <span class="n">results</span><span class="x">,</span> <span class="n">qubits</span>
       <span class="k">end</span>
</code></pre></div></div>

<p>It’s a bit nasty but, save for a few indices, at last we can say we have completed the first feature test. So our final solution, after extracting some constants, is:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">LinearAlgebra</span>

<span class="n">ZERO</span> <span class="o">=</span> <span class="kt">Float32</span><span class="x">(</span><span class="mi">1</span><span class="x">)</span> <span class="o">*</span> <span class="x">[</span><span class="mi">1</span><span class="x">,</span> <span class="mi">0</span><span class="x">]</span>
<span class="n">ONE</span> <span class="o">=</span> <span class="kt">Float32</span><span class="x">(</span><span class="mi">1</span><span class="x">)</span> <span class="o">*</span> <span class="x">[</span><span class="mi">0</span><span class="x">,</span> <span class="mi">1</span><span class="x">]</span>

<span class="n">eye</span> <span class="o">=</span> <span class="kt">Matrix</span><span class="x">{</span><span class="kt">Float32</span><span class="x">}(</span><span class="n">I</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">2</span><span class="x">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="kt">Float32</span><span class="x">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="x">(</span><span class="mi">2</span><span class="x">))</span> <span class="o">*</span> <span class="x">[</span><span class="mi">1</span> <span class="mi">1</span><span class="x">;</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="x">]</span>
<span class="n">M₀</span> <span class="o">=</span> <span class="n">ZERO</span> <span class="o">*</span> <span class="n">ZERO</span><span class="err">'</span>
<span class="n">M₁</span> <span class="o">=</span> <span class="n">ONE</span> <span class="o">*</span> <span class="n">ONE</span><span class="err">'</span>

<span class="n">register</span> <span class="o">=</span> <span class="x">(</span><span class="n">n</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="n">foldl</span><span class="x">(</span><span class="n">kron</span><span class="x">,</span> <span class="n">fill</span><span class="x">(</span><span class="n">ZERO</span><span class="x">,</span> <span class="n">n</span><span class="x">))</span>
<span class="n">hadamard</span> <span class="o">=</span> <span class="x">(</span><span class="n">n</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="n">foldl</span><span class="x">(</span><span class="n">kron</span><span class="x">,</span> <span class="n">fill</span><span class="x">(</span><span class="n">H</span><span class="x">,</span> <span class="n">n</span><span class="x">))</span>

<span class="n">lift</span> <span class="o">=</span> <span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">k</span><span class="x">,</span> <span class="n">op</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="n">foldl</span><span class="x">(</span><span class="n">kron</span><span class="x">,</span> <span class="n">map</span><span class="x">(</span><span class="n">it</span> <span class="o">-&gt;</span> <span class="x">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">k</span><span class="x">)</span> <span class="o">?</span> <span class="n">op</span> <span class="o">:</span> <span class="n">eye</span><span class="x">,</span> <span class="n">collect</span><span class="x">(</span><span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="x">)))</span>

<span class="n">measure</span> <span class="o">=</span> <span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">k</span><span class="x">,</span> <span class="n">qubits</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="k">begin</span>
         <span class="n">result</span> <span class="o">=</span> <span class="n">rand</span><span class="x">()</span> <span class="o">&gt;</span> <span class="n">qubits</span><span class="err">'</span> <span class="o">*</span> <span class="n">lift</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">k</span><span class="x">,</span> <span class="n">M₀</span><span class="x">)</span> <span class="o">*</span> <span class="n">qubits</span>
         <span class="x">(</span><span class="n">result</span><span class="x">,</span> <span class="n">normalize</span><span class="x">(</span><span class="n">lift</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">k</span><span class="x">,</span> <span class="x">(</span><span class="n">result</span> <span class="o">?</span> <span class="n">M₁</span> <span class="o">:</span> <span class="n">M₀</span><span class="x">))</span> <span class="o">*</span> <span class="n">qubits</span><span class="x">))</span>
       <span class="k">end</span>

<span class="n">measureAll</span> <span class="o">=</span> <span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">qubits</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="k">begin</span>
         <span class="n">results</span> <span class="o">=</span> <span class="x">[];</span>
         <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
           <span class="n">result</span><span class="x">,</span> <span class="n">qubits</span> <span class="o">=</span> <span class="n">measure</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">k</span><span class="x">,</span> <span class="n">qubits</span><span class="x">)</span>
           <span class="n">push!</span><span class="x">(</span><span class="n">results</span><span class="x">,</span> <span class="n">result</span><span class="x">)</span>
         <span class="k">end</span>
         <span class="n">results</span><span class="x">,</span> <span class="n">qubits</span>
       <span class="k">end</span>

<span class="n">toInt</span> <span class="o">=</span> <span class="x">(</span><span class="n">b</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="n">reduce</span><span class="x">((</span><span class="n">acc</span><span class="x">,</span> <span class="n">v</span><span class="x">)</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">acc</span> <span class="o">+</span> <span class="x">(</span><span class="n">v</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="x">),</span> <span class="n">b</span><span class="x">,</span> <span class="n">init</span><span class="o">=</span><span class="mi">0</span><span class="x">)</span>

<span class="n">qubits</span> <span class="o">=</span> <span class="n">hadamard</span><span class="x">(</span><span class="mi">3</span><span class="x">)</span> <span class="o">*</span> <span class="n">register</span><span class="x">(</span><span class="mi">3</span><span class="x">)</span>
<span class="n">print</span><span class="x">(</span><span class="n">toInt</span><span class="x">(</span><span class="n">measureAll</span><span class="x">(</span><span class="mi">3</span><span class="x">,</span> <span class="n">qubits</span><span class="x">)[</span><span class="mi">1</span><span class="x">]))</span>
</code></pre></div></div>

<p>Running it to give us a random number from 0 to 7 on the console.</p>

<p>Before we leave it, what’s the performance of this thing in its current form? Let’s see:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">n</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="mi">11</span>
<span class="nd">@time</span> <span class="n">print</span><span class="x">(</span><span class="n">toInt</span><span class="x">(</span><span class="n">measureAll</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">hadamard</span><span class="x">(</span><span class="n">n</span><span class="x">)</span> <span class="o">*</span> <span class="n">register</span><span class="x">(</span><span class="n">n</span><span class="x">))[</span><span class="mi">1</span><span class="x">]))</span>
<span class="k">end</span>
</code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">1  0.834134 seconds (1.63 M allocations: 90.474 MiB, 2.38% gc time)
0  0.063235 seconds (15.49 k allocations: 813.162 KiB)
7  0.004201 seconds (9.11 k allocations: 281.986 KiB)
11  0.002534 seconds (27.13 k allocations: 623.813 KiB)
30  0.011686 seconds (122.15 k allocations: 2.509 MiB)
7  0.023647 seconds (634.68 k allocations: 12.326 MiB)
1  0.086709 seconds (3.05 M allocations: 58.193 MiB, 5.11% gc time)
185  0.362644 seconds (14.04 M allocations: 265.855 MiB, 1.72% gc time)
237  1.746489 seconds (63.02 M allocations: 1.163 GiB, 6.29% gc time)
504  7.655970 seconds (279.03 M allocations: 5.145 GiB, 11.96% gc time)
490 31.689085 seconds (1.29 G allocations: 23.612 GiB, 4.77% gc time)
</span></code></pre></div></div>

<p>At just 11 bits it’s taking up huge parts of my machine and far exceeding available main memory. Now we have the machinery written in Julia we can try a number of things to improve performance:</p>

<ul>
  <li>We’re using dense matrices everywhere. We can improve that by using sparse matrices where appropriate. The lifting matrix., especially, is open for conversion to a sparse matrix representation.</li>
  <li>Since the vectors can become quite large it makes sense to do the multiplications in-place, breaking the immutability of the functional paradigm but improving the performance and memory usage which will be very important for larger registers. May be necessary to write our own algorithm to do that using sparse matrices and dense arrays.</li>
</ul>

<p>Also there are a number of other improvements to consider:</p>
<ul>
  <li>We pass around the number of bits when it could be determined implicitly from the size of the arrays.</li>
  <li>There is no entanglement yet in our system, for that we need to define a Conditional NOT operator and for that a more sophisticated <code class="language-plaintext highlighter-rouge">lift</code> function.</li>
</ul>

<p>We’ll cover all that in another post.</p>



<div id="share-bar">

    <div class="share-buttons">
        Share this:
        <a  href="https://twitter.com/intent/tweet?text=Building a QPU simulator in Julia - Part 2&url=https://johnhearn.github.io//articles/building-a-qpu-simulator-in-julia-part-2"
            onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;"
            title="Share on Twitter" >
            <i class="fa-lg fab fa-twitter share-button"></i>
        </a>
        <a  href="https://www.linkedin.com/shareArticle?mini=true&url=https://johnhearn.github.io//articles/building-a-qpu-simulator-in-julia-part-2&title=Building a QPU simulator in Julia - Part 2&summary=Starting again with Julia.&source=John Hearn"
            onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;"
            title="Share on LinkedIn" >
            <i class="fa-lg fab fa-linkedin share-button"></i>
        </a>
        <a  href="mailto:?subject=Building a QPU simulator in Julia - Part 2&amp;body=Check out this site https://johnhearn.github.io//articles/building-a-qpu-simulator-in-julia-part-2"
            title="Share via Email" >
            <i class="fa-lg fa fa-envelope-open share-button"></i>
        </a>
    </div>

</div>

    </article>
    <span class="print-footer">Building a QPU simulator in Julia - Part 2 - May 7, 2019 - John Hearn</span>
    <footer>
  <hr class="slender">
  <ul class="footer-links">
    <li>
        <a href="https://twitter.com/johnhearnbcn">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
        </span>
        </a>
    </li>
    <li>
        <a href="https://github.com/johnhearn">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fab fa-github fa-stack-1x fa-inverse"></i>
        </span>
        </a>
    </li>
    <li>
        <a href="https://www.linkedin.com/in/john-hearn-599762b">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
        </span>
        </a>
    </li>
    <li>
        <a href="mailto:hearn.john@gmail.com">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope-open fa-stack-1x fa-inverse"></i>
        </span>
        </a>
    </li>
</ul>

<div class="credits">
<span>&copy; 2025 &nbsp;&nbsp;JOHN HEARN</span></br> <br>
<span>This site created with the <a href="//github.com/clayh53/tufte-jekyll">Tufte theme</a> for <a href="//jekyllrb.com">Jekyll</a>.</span> 
</div>  
</footer>
  </body>
</html>
